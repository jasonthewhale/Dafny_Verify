[{"prompt": "function Sum(arr: array<int>, len: int): int\n    reads arr\n    requires arr.Length > 0 && 0 <= len <= arr.Length\n{\n    if len == 0 then 0 else arr[len-1] + Sum(arr, len-1)\n}\n\nmethod SumArray(arr: array<int>) returns (sum: int)\n    requires arr.Length > 0\n    ensures sum == Sum(arr, arr.Length)\n{\n    sum := 0;\n    var i := 0;\n    while i < arr.Length\n    {\n        sum := sum + arr[i];\n        i := i + 1;\n    }\n}", "completion": "function Sum(arr: array<int>, len: int): int\n    reads arr\n    requires arr.Length > 0 && 0 <= len <= arr.Length\n{\n    if len == 0 then 0 else arr[len-1] + Sum(arr, len-1)\n}\n\nmethod SumArray(arr: array<int>) returns (sum: int)\n    requires arr.Length > 0\n    ensures sum == Sum(arr, arr.Length)\n{\n    sum := 0;\n    var i := 0;\n    while i < arr.Length\n        invariant 0 <= i <= arr.Length\n        invariant sum == Sum(arr, i)\n    {\n        sum := sum + arr[i];\n        i := i + 1;\n    }\n}"}, {"prompt": "function contains(v: int, a: array<int>, n: int): bool \nreads a\n  requires n >= 0 && n <= a.Length\n{\n  exists j: int :: 0 <= j < n && a[j] == v\n}\n\nfunction lower_bound(v: int, a: array<int>, n: int): bool \nreads a\n  requires n >= 0 && n <= a.Length\n{\n  forall j: int :: 0 <= j < n ==> a[j] >= v\n}\n\nmethod min(a: array<int>, n: int) returns (min: int)\n  requires n > 0 && n <= a.Length;\n  ensures contains(min, a, n);\n  ensures lower_bound(min, a, n);\n{\n  var i: int;\n  min := a[0];\n  i := 1;\n\n  while i < n\n  {\n    if a[i] < min {\n      min := a[i];\n    }\n    i := i + 1;\n  }\n}\n", "completion": "function contains(v: int, a: array<int>, n: int): bool \nreads a\n  requires n >= 0 && n <= a.Length\n{\n  exists j: int :: 0 <= j < n && a[j] == v\n}\n\nfunction lower_bound(v: int, a: array<int>, n: int): bool \nreads a\n  requires n >= 0 && n <= a.Length\n{\n  forall j: int :: 0 <= j < n ==> a[j] >= v\n}\n\nmethod min(a: array<int>, n: int) returns (min: int)\n  requires n > 0 && n <= a.Length;\n  ensures contains(min, a, n);\n  ensures lower_bound(min, a, n);\n{\n  var i: int;\n  min := a[0];\n  i := 1;\n\n  while i < n \n    invariant 0 <= i <= n;\n    invariant contains(min, a, i);\n    invariant lower_bound(min, a, i);\n  {\n    if a[i] < min {\n      min := a[i];\n    }\n    i := i + 1;\n  }\n}\n"}, {"prompt": "method main(n: int, k: int) returns (i :int, j: int)\n    requires n >= 0\n    requires k == 1 || k >= 0\n    ensures k + i + j >= 2 * n\n{\n    i := 0;\n    j := 0;\n    while(i < n)\n    {\n        i := i + 1;\n        j := j + i;\n    }\n}", "completion": "method main(n: int, k: int) returns (i :int, j: int)\n    requires n >= 0\n    requires k == 1 || k >= 0\n    ensures k + i + j >= 2 * n\n{\n    i := 0;\n    j := 0;\n    while(i < n)\n        invariant 0 <= i <= n\n        invariant j == i * (i + 1) / 2\n    {\n        i := i + 1;\n        j := j + i;\n    }\n}"}, {"prompt": "method Minimum(a: array<int>) returns (m: int) \n\trequires a.Length > 0\n\tensures exists i :: 0 <= i < a.Length && m == a[i]\n\tensures forall i :: 0 <= i < a.Length ==> m <= a[i]\n{\n\tvar n := 0;\n\tm := a[0];\n\twhile n != a.Length\n\t{\n\t\tif a[n] < m {\n\t\t\tm := a[n];\n\t\t}\n\t\tn := n + 1;\n\t}\n}", "completion": "method Minimum(a: array<int>) returns (m: int) \n\trequires a.Length > 0\n\tensures exists i :: 0 <= i < a.Length && m == a[i]\n\tensures forall i :: 0 <= i < a.Length ==> m <= a[i]\n{\n\tvar n := 0;\n\tm := a[0];\n\twhile n != a.Length\n\t\tinvariant 0 <= n <= a.Length\n\t\tinvariant forall i :: 0 <= i < n ==> m <= a[i]\n\t\tinvariant exists i :: 0 <= i < a.Length && m == a[i]\n\t{\n\t\tif a[n] < m {\n\t\t\tm := a[n];\n\t\t}\n\t\tn := n + 1;\n\t}\n}"}, {"prompt": "method mult(a:int, b:int) returns (x:int)\n  \trequires a >= 0 && b >= 0\n  \tensures x == a * b\n{\n  \tx := 0;\n\tvar y := a;\n  \twhile y > 0\n\t{\n\t\tx := x + b;\n\t\ty := y - 1;\n\t}\n}", "completion": "method mult(a:int, b:int) returns (x:int)\n  \trequires a >= 0 && b >= 0\n  \tensures x == a * b\n{\n  \tx := 0;\n\tvar y := a;\n  \twhile y > 0\n        invariant y >= 0\n\t\tinvariant x == (a-y) * b\n\t{\n\t\tx := x + b;\n\t\ty := y - 1;\n\t}\n}"}, {"prompt": "function contains(v: int, a: array<int>, n: int): bool \nreads a\n  requires n >= 0 && n <= a.Length\n{\n  exists j: int :: 0 <= j < n && a[j] == v\n}\n\nfunction lower_bound(v: int, a: array<int>, n: int): bool \nreads a\n  requires n >= 0 && n <= a.Length\n{\n  forall j: int :: 0 <= j < n ==> a[j] >= v\n}\n\nfunction is_min(m: int, a: array<int>, n: int): bool \nreads a\n  requires n >= 0 && n <= a.Length\n{\n  contains(m, a, n) && lower_bound(m, a, n)\n}\n\nmethod min(a: array<int>, n: int) returns (min: int)\n  requires 0 < n <= a.Length;\n  ensures is_min(min, a, n);\n{\n  var i: int;\n  min := a[0];\n  i := 1;\n\n  while i < n\n  {\n    if a[i] < min {\n      min := a[i];\n    }\n    i := i + 1;\n  }\n}\n", "completion": "function contains(v: int, a: array<int>, n: int): bool \nreads a\n  requires n >= 0 && n <= a.Length\n{\n  exists j: int :: 0 <= j < n && a[j] == v\n}\n\nfunction lower_bound(v: int, a: array<int>, n: int): bool \nreads a\n  requires n >= 0 && n <= a.Length\n{\n  forall j: int :: 0 <= j < n ==> a[j] >= v\n}\n\nfunction is_min(m: int, a: array<int>, n: int): bool \nreads a\n  requires n >= 0 && n <= a.Length\n{\n  contains(m, a, n) && lower_bound(m, a, n)\n}\n\nmethod min(a: array<int>, n: int) returns (min: int)\n  requires 0 < n <= a.Length;\n  ensures is_min(min, a, n);\n{\n  var i: int;\n  min := a[0];\n  i := 1;\n\n  while i < n \n    invariant 0 <= i <= n;\n    invariant is_min(min, a, i);\n  {\n    if a[i] < min {\n      min := a[i];\n    }\n    i := i + 1;\n  }\n}\n"}, {"prompt": "method Quotient1() \n{\n    var x, y := 0, 191;\n    while 7 <= y\n    {\n        x, y := 27, 2;\n    }\n    assert x == 191 / 7 && y == 191 % 7;\n}", "completion": "method Quotient1() \n{\n    var x, y := 0, 191;\n    while 7 <= y\n    invariant 0 <= y && 7 * x + y == 191\n    {\n        x, y := 27, 2;\n    }\n    assert x == 191 / 7 && y == 191 % 7;\n}"}, {"prompt": "function even(n: int): bool\n  requires n >= 0\n{\n  if n == 0 then true else !even(n-1)\n}\n\nmethod is_even(n: int) returns (r: bool)\n  requires n >= 0;\n  ensures r <==> even(n);\n{\n  var i: int := 0;\n  r := true;\n\n  while i < n\n  {\n    r := !r;\n    i := i + 1;\n  }\n}\n", "completion": "function even(n: int): bool\n  requires n >= 0\n{\n  if n == 0 then true else !even(n-1)\n}\n\nmethod is_even(n: int) returns (r: bool)\n  requires n >= 0;\n  ensures r <==> even(n);\n{\n  var i: int := 0;\n  r := true;\n\n  while i < n\n    invariant i <= n;\n    invariant r <==> even(i);\n  {\n    r := !r;\n    i := i + 1;\n  }\n}\n"}, {"prompt": "method main(n: int, k: int) returns (i: int, j :int)\nrequires n ==1 || n == 2\nensures (n != 1) || (i == j)\n{\n    i := 0;\n    j := 0;\n    while(i <= k)\n    {\n        i := i + 1;\n        j := j + n;\n    }\n}", "completion": "method main(n: int, k: int) returns (i: int, j :int)\nrequires n ==1 || n == 2\nensures (n != 1) || (i == j)\n{\n    i := 0;\n    j := 0;\n    while(i <= k)\n        invariant i >= 0 && j == i * n;\n    {\n        i := i + 1;\n        j := j + n;\n    }\n}"}, {"prompt": "ghost function Power(n: nat): nat {\n    if n == 0 then 1 else 2 * Power(n - 1)\n}\n\nmethod ComputePower(n: nat) returns (p: nat)\n    ensures p == Power(n)\n{\n    p := 1;\n    var i := 0;\n    while i != n\n    {\n        i := i + 1;\n        p := p * 2;\n    }\n}\n", "completion": "ghost function Power(n: nat): nat {\n    if n == 0 then 1 else 2 * Power(n - 1)\n}\n\nmethod ComputePower(n: nat) returns (p: nat)\n    ensures p == Power(n)\n{\n    p := 1;\n    var i := 0;\n    while i != n\n        invariant 0 <= i <= n\n        invariant p == Power(i)\n    {\n        i := i + 1;\n        p := p * 2;\n    }\n}\n"}, {"prompt": "method square (n: int) returns (r: int)\n\trequires 0 <= n;\n\tensures r == n*n;\n{\n\tvar x: int;\n\tvar i: int;\n\n\tr := 0;\n\ti := 0;\n\tx := 1;\n\n\twhile (i < n)\n\t{\n\t\tr := r + x;\n\t\tx := x + 2;\n\t\ti := i + 1;\n\t}\n}", "completion": "method square (n: int) returns (r: int)\n\trequires 0 <= n;\n\tensures r == n*n;\n{\n\tvar x: int;\n\tvar i: int;\n\n\tr := 0;\n\ti := 0;\n\tx := 1;\n\n\twhile (i < n)\n\t\tinvariant i <= n;\n\t\tinvariant r == i*i;\n\t\tinvariant x == 2*i + 1;\n\t{\n\t\tr := r + x;\n\t\tx := x + 2;\n\t\ti := i + 1;\n\t}\n}"}, {"prompt": "method square (n: int) returns (r: int)\n\trequires 0 <= n;\n\tensures r == n*n;\n{\n\tvar i: int;\n\n\ti := 0;\n\tr := 0;\n\n\twhile (i < n)\n\t{\n\t\tr := r + n;\n\t\ti := i + 1;\n\t}\n}\n", "completion": "method square (n: int) returns (r: int)\n\trequires 0 <= n;\n\tensures r == n*n;\n{\n\tvar i: int;\n\n\ti := 0;\n\tr := 0;\n\n\twhile (i < n)\n\t\tinvariant i <= n;\n\t\tinvariant r == i*n;\n\t{\n\t\tr := r + n;\n\t\ti := i + 1;\n\t}\n}\n"}, {"prompt": "datatype List<T> = Nil | Cons(head: T, tail: List<T>)\n\nfunction Length<T>(xs: List<T>): nat {\n    match xs\n    case Nil => 0\n    case Cons(_, tail) => 1 + Length(tail)\n}\n\nmethod repeatValue<T>(d: T, n: nat) returns (result: List<T>)\n    ensures Length(result) == n\n{\n    result := Nil;\n    var i := 0;\n    while i < n\n    {\n        result := Cons(d, result);\n        i := i + 1;\n    }\n}", "completion": "datatype List<T> = Nil | Cons(head: T, tail: List<T>)\n\nfunction Length<T>(xs: List<T>): nat {\n    match xs\n    case Nil => 0\n    case Cons(_, tail) => 1 + Length(tail)\n}\n\nmethod repeatValue<T>(d: T, n: nat) returns (result: List<T>)\n    ensures Length(result) == n\n{\n    result := Nil;\n    var i := 0;\n    while i < n\n        invariant i <= n\n        invariant Length(result) == i\n    {\n        result := Cons(d, result);\n        i := i + 1;\n    }\n}"}, {"prompt": "method main() returns (i: int, x: int, y: int, m: int)\nensures (i != m) || (x == 2*y)\n{\n    x := 0;\n    y := 0;\n    i := 0;\n    m := 10;\n\n    while(i < m)\n    {\n\t\ti := i + 1;\n\t\tx := x + 1;\n\n\t\tif(x % 2 == 0){\n\t\t\ty := y + 1;\n\t\t}\n\t\telse{}\n\t}\n}", "completion": "method main() returns (i: int, x: int, y: int, m: int)\nensures (i != m) || (x == 2*y)\n{\n    x := 0;\n    y := 0;\n    i := 0;\n    m := 10;\n\n    while(i < m)\n        invariant 0 <= i <= m\n        invariant x == i\n        invariant y == i / 2\n    {\n\t\ti := i + 1;\n\t\tx := x + 1;\n\n\t\tif(x % 2 == 0){\n\t\t\ty := y + 1;\n\t\t}\n\t\telse{}\n\t}\n}"}, {"prompt": "function contains(v: int, a: array<int>, n: int): bool\nreads a\n  requires n <= a.Length\n{\n  exists j :: 0 <= j < n && a[j] == v\n}\n\nfunction upper_bound(v: int, a: array<int>, n: int): bool\nreads a\n  requires n <= a.Length\n{\n  forall j :: 0 <= j < n ==> a[j] <= v\n}\n\nfunction is_max(m: int, a: array<int>, n: int): bool\nreads a\n  requires n <= a.Length\n{\n  contains(m, a, n) && upper_bound(m, a, n)\n}\n\nmethod max(a: array<int>, n: int) returns (max: int)\n  requires 0 < n <= a.Length;\n  ensures is_max(max, a, n);\n{\n  var i: int := 1;\n\n  max := a[0];\n\n  while i < n\n  {\n    if a[i] > max {\n      max := a[i];\n    }\n    i := i + 1;\n  }\n}\n", "completion": "function contains(v: int, a: array<int>, n: int): bool\nreads a\n  requires n <= a.Length\n{\n  exists j :: 0 <= j < n && a[j] == v\n}\n\nfunction upper_bound(v: int, a: array<int>, n: int): bool\nreads a\n  requires n <= a.Length\n{\n  forall j :: 0 <= j < n ==> a[j] <= v\n}\n\nfunction is_max(m: int, a: array<int>, n: int): bool\nreads a\n  requires n <= a.Length\n{\n  contains(m, a, n) && upper_bound(m, a, n)\n}\n\nmethod max(a: array<int>, n: int) returns (max: int)\n  requires 0 < n <= a.Length;\n  ensures is_max(max, a, n);\n{\n  var i: int := 1;\n\n  max := a[0];\n\n  while i < n\n\t\tinvariant i <= n;\n\t\tinvariant is_max (max, a, i);\n  {\n    if a[i] > max {\n      max := a[i];\n    }\n    i := i + 1;\n  }\n}\n"}, {"prompt": "method SelectionSort(a: array<int>)\n  modifies a\n  ensures forall i,j :: 0 <= i < j < a.Length ==> a[i] <= a[j]\n  ensures multiset(a[..]) == old(multiset(a[..]))\n{\n  var n := 0;\n  while n != a.Length\n  {\n    var mindex, m := n, n;\n    while m != a.Length\n    {\n      if a[m] < a[mindex] {\n        mindex := m;\n      }\n      m := m + 1;\n    }\n    if a[mindex] < a[n] {\n      a[mindex], a[n] := a[n], a[mindex];\n    }\n    n := n + 1;\n  }  \n}", "completion": "method SelectionSort(a: array<int>)\n  modifies a\n  ensures forall i,j :: 0 <= i < j < a.Length ==> a[i] <= a[j]\n  ensures multiset(a[..]) == old(multiset(a[..]))\n{\n  var n := 0;\n  while n != a.Length\n    invariant 0 <= n <= a.Length\n    invariant forall i,j :: 0 <= i < j < a.Length && j < n ==> a[i] <= a[j]\n    invariant forall i :: 0 <= i < n ==> forall j :: n <= j < a.Length ==> a[i] <= a[j]\n    invariant multiset(a[..]) == old(multiset(a[..]))\n  {\n    var mindex, m := n, n;\n    while m != a.Length\n      invariant n <= mindex < a.Length\n      invariant n <= m <= a.Length\n      invariant forall i :: n <= i < m ==> a[mindex] <= a[i]\n      invariant multiset(a[..]) == old(multiset(a[..]))\n    {\n      if a[m] < a[mindex] {\n        mindex := m;\n      }\n      m := m + 1;\n    }\n    if a[mindex] < a[n] {\n      a[mindex], a[n] := a[n], a[mindex];\n    }\n    n := n + 1;\n  }  \n}"}, {"prompt": "method max(a: array<int>, n: int) returns (max: int)\n  requires n > 0;\n  requires n <= a.Length;\n  ensures exists i :: 0 <= i < n && a[i] == max;\n  ensures forall i :: 0 <= i < n ==> a[i] <= max;\n{\n  var i: int;\n\n  max := a[0];\n  i := 1;\n\n  while i < n\n  {\n    if (a[i] > max) {\n      max := a[i];\n    }\n    i := i + 1;\n  }\n}", "completion": "method max(a: array<int>, n: int) returns (max: int)\n  requires n > 0;\n  requires n <= a.Length;\n  ensures exists i :: 0 <= i < n && a[i] == max;\n  ensures forall i :: 0 <= i < n ==> a[i] <= max;\n{\n  var i: int;\n\n  max := a[0];\n  i := 1;\n\n  while i < n\n    invariant i <= n;\n    invariant exists j :: 0 <= j < i && a[j] == max;\n    invariant forall j :: 0 <= j < i ==> a[j] <= max;\n  {\n    if (a[i] > max) {\n      max := a[i];\n    }\n    i := i + 1;\n  }\n}"}, {"prompt": "method main(n: int) returns (x: int)\nrequires n > 0\nensures x == n\n{\n    x := 0;\n    while(x < n)\n    {\n        x := x + 1;\n    }\n}", "completion": "method main(n: int) returns (x: int)\nrequires n > 0\nensures x == n\n{\n    x := 0;\n    while(x < n) \n        invariant 0 <= x <= n\n    {\n        x := x + 1;\n    }\n}"}, {"prompt": "method main(n: int) returns (i: int, v: int, k: int, c1: int, c2: int)\nrequires n > 0 && n < 10\nensures k > n\n{\n    i := 0;\n    k := 0;\n    v := 0;\n    c1 := 4000;\n    c2 := 2000;\n    while(i < n)\n    {\n        i := i + 1;\n        \n        if(*){\n            v := 0;\t\t\n        }\n        else{\n            v := 1;\n        }\n\n        if(v == 0){\n            k := k + c1;\n        }\n        else{\n            k := k + c2;\n        }\n    }\n}", "completion": "method main(n: int) returns (i: int, v: int, k: int, c1: int, c2: int)\nrequires n > 0 && n < 10\nensures k > n\n{\n    i := 0;\n    k := 0;\n    v := 0;\n    c1 := 4000;\n    c2 := 2000;\n    while(i < n)\n        invariant 0 <= i <= n\n        invariant i * c2 <= k <= i * c1;\n    {\n        i := i + 1;\n        \n        if(*){\n            v := 0;\t\t\n        }\n        else{\n            v := 1;\n        }\n\n        if(v == 0){\n            k := k + c1;\n        }\n        else{\n            k := k + c2;\n        }\n    }\n}"}, {"prompt": "function Fib(n: nat): nat {\n if n < 2 then n else Fib(n - 2) + Fib(n - 1)\n}\n\nmethod ComputeFib(n: nat) returns (x: nat)\n    ensures x == Fib(n)\n{\n    x := 0;\n    var i := 0;\n    var y := 1;\n    while i != n\n\n    {\n        x, y := y, x + y;\n        i := i + 1;\n    }\n}\n", "completion": "function Fib(n: nat): nat {\n if n < 2 then n else Fib(n - 2) + Fib(n - 1)\n}\n\nmethod ComputeFib(n: nat) returns (x: nat)\n    ensures x == Fib(n)\n{\n    x := 0;\n    var i := 0;\n    var y := 1;\n    while i != n\n        invariant x == Fib(i) && y == Fib(i + 1)\n        invariant i <= n\n\n    {\n        x, y := y, x + y;\n        i := i + 1;\n    }\n}\n"}, {"prompt": "method main(n: int) returns(x: int, m: int)\nrequires n > 0\nensures (n <= 0) || (0 <= m && m < n)\n{\n    x := 0;\n    m := 0;\n\n    while(x < n)\n    {\n        if(*)\n        {\n            m := x;\n        }\n        else{}\n        x := x + 1;\n    }\n}", "completion": "method main(n: int) returns(x: int, m: int)\nrequires n > 0\nensures (n <= 0) || (0 <= m && m < n)\n{\n    x := 0;\n    m := 0;\n\n    while(x < n)\n        invariant 0 <= x <= n\n        invariant 0 <= m < n\n    {\n        if(*)\n        {\n            m := x;\n        }\n        else{}\n        x := x + 1;\n    }\n}"}, {"prompt": "function has_count(v: int, a: array<int>, n: int): int\n    reads a  // This allows the function to read from array 'a'\n    requires n >= 0 && n <= a.Length\n{\n    if n == 0 then 0 else\n    (if a[n-1] == v then has_count(v, a, n-1) + 1 else has_count(v, a, n-1))\n}\n\n\nmethod count (v: int, a: array<int>, n: int) returns (r: int)\n\trequires n >= 0 && n <= a.Length;\n\tensures has_count (v, a, n) == r;\n{\n\tvar i: int;\n\n\ti := 0;\n\tr := 0;\n\n\twhile (i < n)\n\t{\n\t\tif (a[i] == v)\n\t\t{\n\t\t\tr := r + 1;\n\t\t}\n\t\ti := i + 1;\n\t}\n}", "completion": "function has_count(v: int, a: array<int>, n: int): int\n    reads a  // This allows the function to read from array 'a'\n    requires n >= 0 && n <= a.Length\n{\n    if n == 0 then 0 else\n    (if a[n-1] == v then has_count(v, a, n-1) + 1 else has_count(v, a, n-1))\n}\n\n\nmethod count (v: int, a: array<int>, n: int) returns (r: int)\n\trequires n >= 0 && n <= a.Length;\n\tensures has_count (v, a, n) == r;\n{\n\tvar i: int;\n\n\ti := 0;\n\tr := 0;\n\n\twhile (i < n)\n\t\tinvariant i <= n;\n\t\tinvariant has_count (v, a, i) == r;\n\t{\n\t\tif (a[i] == v)\n\t\t{\n\t\t\tr := r + 1;\n\t\t}\n\t\ti := i + 1;\n\t}\n}"}, {"prompt": "method LinearSearch<T>(a: array<T>, P: T -> bool) returns (n: int)\n    ensures 0 <= n <= a.Length\n    ensures n == a.Length || P(a[n])\n{\n    n := 0;\n    while n != a.Length\n    {\n        if P(a[n]) {\n            return;\n        }\n        n := n + 1;\n    }\n}", "completion": "method LinearSearch<T>(a: array<T>, P: T -> bool) returns (n: int)\n    ensures 0 <= n <= a.Length\n    ensures n == a.Length || P(a[n])\n{\n    n := 0;\n    while n != a.Length\n    invariant 0 <= n <= a.Length\n    invariant forall i: int :: 0 <= i < n ==> !P(a[i])\n    {\n        if P(a[n]) {\n            return;\n        }\n        n := n + 1;\n    }\n}"}, {"prompt": "function has_even(v: bool, a: array<bool>, n: int): bool\nreads a;\n  requires n >= 0;\n  requires n <= a.Length;\n{\n  if n == 0 then\n    false\n  else if a[n-1] == v then\n    !has_even(v, a, n-1)\n  else\n    has_even(v, a, n-1)\n}\n\nmethod even_true(a: array<bool>, n: int) returns (even: bool)\n  requires n >= 0;\n  requires n <= a.Length;\n  ensures has_even(true, a, n) <==> even;\n{\n  var i: int := 0;\n  even := false;\n\n  while(i < n)\n  {\n    if(a[i])\n    {\n      even := !even;\n    }\n    i := i + 1;\n  }\n}\n", "completion": "function has_even(v: bool, a: array<bool>, n: int): bool\nreads a;\n  requires n >= 0;\n  requires n <= a.Length;\n{\n  if n == 0 then\n    false\n  else if a[n-1] == v then\n    !has_even(v, a, n-1)\n  else\n    has_even(v, a, n-1)\n}\n\nmethod even_true(a: array<bool>, n: int) returns (even: bool)\n  requires n >= 0;\n  requires n <= a.Length;\n  ensures has_even(true, a, n) <==> even;\n{\n  var i: int := 0;\n  even := false;\n\n  while(i < n)\n    invariant i <= n;\n    invariant has_even(true, a, i) <==> even;\n  {\n    if(a[i])\n    {\n      even := !even;\n    }\n    i := i + 1;\n  }\n}\n"}, {"prompt": "method main(n: int, flag: int) returns (j: int, b: int)\nrequires n > 0\nensures (flag != 1) || (j == n)\n{\n    j := 0;\n    b := 0;\n\n    while(b < n)\n    {\n        if(flag == 1){\n            j := j + 1;\n        }\n        else{}\n        b := b + 1;\n    }\n}", "completion": "method main(n: int, flag: int) returns (j: int, b: int)\nrequires n > 0\nensures (flag != 1) || (j == n)\n{\n    j := 0;\n    b := 0;\n\n    while(b < n)\n        invariant 0 <= b <= n\n        invariant (flag != 1) || (j == b)\n    {\n        if(flag == 1){\n            j := j + 1;\n        }\n        else{}\n        b := b + 1;\n    }\n}"}, {"prompt": "method main(n: int) returns (c: int, i: int)\nrequires n > 0\nensures c >= 0\n{\n    c := 0;\n    i := 0;\n    while(i < n)\n    {\n        c := c + i;\n        i := i + 1;\n    }\n}", "completion": "method main(n: int) returns (c: int, i: int)\nrequires n > 0\nensures c >= 0\n{\n    c := 0;\n    i := 0;\n    while(i < n)\n        invariant 0 <= i <= n\n        invariant c == i * (i - 1) / 2\n    {\n        c := c + i;\n        i := i + 1;\n    }\n}"}, {"prompt": "method main(m: int, n: int) returns (x: int, y: int)\nrequires m >= 0\nrequires n >= 0\nrequires m < n\nensures y == n\n{\n    x := 0;\n    y := m;\n\n    while (x < n)\n    {\n        x := x + 1;\n        if (x > m) \n        {\n            y := y + 1;\n        }\n        else \n        {}\n    }\n}", "completion": "method main(m: int, n: int) returns (x: int, y: int)\nrequires m >= 0\nrequires n >= 0\nrequires m < n\nensures y == n\n{\n    x := 0;\n    y := m;\n\n    while (x < n)\n        invariant 0 <= x <= n\n        invariant m <= y <= n\n        invariant y == m + (if x > m then x - m else 0)\n    {\n        x := x + 1;\n        if (x > m) \n        {\n            y := y + 1;\n        }\n        else \n        {}\n    }\n}"}, {"prompt": "method main(m: int) returns (a: int)\n    requires m > 0\n    ensures a >= -m\n    ensures a <= m\n{\n    a := 0;\n    var j: int := 1;\n\n    while (j <= m)\n    {\n        if (*)\n        {\n            a := a + 1;\n        }\n        else\n        {\n            a := a - 1;\n        }\n\n        j := j + 1;\n    }\n}", "completion": "method main(m: int) returns (a: int)\n    requires m > 0\n    ensures a >= -m\n    ensures a <= m\n{\n    a := 0;\n    var j: int := 1;\n\n    while (j <= m)\n        invariant 1 <= j <= m + 1\n        invariant 1 - j <= a <= j -1\n    {\n        if (*)\n        {\n            a := a + 1;\n        }\n        else\n        {\n            a := a - 1;\n        }\n\n        j := j + 1;\n    }\n}"}, {"prompt": "method main(x: int, y: int) returns (x_out: int, y_out: int, n: int)\nrequires x >= 0\nrequires y >= 0\nrequires x == y\nensures y_out == n\n{\n    x_out := x;\n    y_out := y;\n    n := 0;\n\n    while (x_out != n)\n    {\n        x_out := x_out - 1;\n        y_out := y_out - 1;\n    }\n}", "completion": "method main(x: int, y: int) returns (x_out: int, y_out: int, n: int)\nrequires x >= 0\nrequires y >= 0\nrequires x == y\nensures y_out == n\n{\n    x_out := x;\n    y_out := y;\n    n := 0;\n\n    while (x_out != n)\n        invariant x_out >= 0\n        invariant x_out == y_out\n    {\n        x_out := x_out - 1;\n        y_out := y_out - 1;\n    }\n}"}, {"prompt": "method Main(xInit: int, y: int) returns (z: int)\n  requires xInit >= 0\n  requires y >= 0\n  ensures z == 0\n{\n  var x := xInit;\n  z := x * y;\n  \n  while x > 0\n    decreases x\n  {\n    x := x - 1;\n    z := z - y;\n  }\n}\n", "completion": "method Main(xInit: int, y: int) returns (z: int)\n  requires xInit >= 0\n  requires y >= 0\n  ensures z == 0\n{\n  var x := xInit;\n  z := x * y;\n  \n  while x > 0\n    decreases x // This ensures termination of the loop\n    invariant z == x * y // This ensures that z is always equal to x * y, even during the loop\n  {\n    x := x - 1;\n    z := z - y;\n  }\n}\n"}, {"prompt": "method main() returns (t1: int, t2: int, x: int, y: int)\nensures y >= 1\n{\n    x := 1;\n    y := 1;\n    t1 := 0;\n    t2 := 0;\n\n    while(x <= 100000)\n    {\n        t1 := x;\n        t2 := y;\n        x := t1 + t2;\n        y := t1 + t2;\n    }\n}\n", "completion": "method main() returns (t1: int, t2: int, x: int, y: int)\nensures y >= 1\n{\n    x := 1;\n    y := 1;\n    t1 := 0;\n    t2 := 0;\n\n    while(x <= 100000) \n        invariant x == y;\n    {\n        t1 := x;\n        t2 := y;\n        x := t1 + t2;\n        y := t1 + t2;\n    }\n}\n"}, {"prompt": "method main(n: int, k: int) returns (k_out: int)\n    requires n > 0;\n\trequires k > n;\n\tensures k_out >= 0;\n{\n\tk_out := k;\n    var j: int := 0;\n    while(j < n)\n    {\n        j := j + 1;\n        k_out := k_out - 1;\n    }\n}", "completion": "method main(n: int, k: int) returns (k_out: int)\n    requires n > 0;\n\trequires k > n;\n\tensures k_out >= 0;\n{\n\tk_out := k;\n    var j: int := 0;\n    while(j < n)\n\t\tinvariant 0 <= j <= n;\n\t\tinvariant j + k_out == k;\n    {\n        j := j + 1;\n        k_out := k_out - 1;\n    }\n}"}, {"prompt": "method Main() returns (x: int, y: int)\n\tensures x == y;\n{\n\tx := 0;\n\ty := 0;\n\tvar w := 1;\n\tvar z := 0;\n\tvar turn := 0;\n\n\twhile(x != y)\n\t{\n\t\tif(turn == 0){\n\t\t\tturn := 1;\n\t\t}\n\n\t\tif(turn == 1){\n\t\t\tif(w % 2 == 1){\n\t\t\t\tx := x + 1;\n\t\t\t}\n\n\t\t\tif(z % 2 == 0){\n\t\t\t\ty := y + 1;\n\t\t\t}\n\n\t\t\tturn := 1;\n\t\t}\n\t\telse{\n\t\t\tif(turn == 2){\n\t\t\t\tz := z + y;\n\t\t\t\tw := z + 1;\n\n\t\t\t\tturn := 0;\n\t\t\t}\n\t\t}\n\t}\n}\n\n\n", "completion": "method Main() returns (x: int, y: int)\n\tensures x == y;\n{\n\tx := 0;\n\ty := 0;\n\tvar w := 1;\n\tvar z := 0;\n\tvar turn := 0;\n\n\twhile(x != y)\n\tinvariant x == y ==> !(0 <= -z*2/2 && 1 <= -(w-1)*2/2) \n    invariant !((x != y && x - y <= -1) || (x - y >= 1 && -z*2/2 <= 0 && (w-1)*2/2 <= 1))\n    invariant !(w*2/2 <= 0 && ((x != y && (x - y <= -1 || x - y >= 1)) || 1 <= z*2/2))\n\n\t{\n\t\tif(turn == 0){\n\t\t\tturn := 1;\n\t\t}\n\n\t\tif(turn == 1){\n\t\t\tif(w % 2 == 1){\n\t\t\t\tx := x + 1;\n\t\t\t}\n\n\t\t\tif(z % 2 == 0){\n\t\t\t\ty := y + 1;\n\t\t\t}\n\n\t\t\tturn := 1;\n\t\t}\n\t\telse{\n\t\t\tif(turn == 2){\n\t\t\t\tz := z + y;\n\t\t\t\tw := z + 1;\n\n\t\t\t\tturn := 0;\n\t\t\t}\n\t\t}\n\t}\n}\n\n\n"}, {"prompt": "datatype List<T> = Nil | Cons(head: T, tail: List<T>)\n\nfunction Length<T>(xs: List<T>): nat {\n    match xs\n    case Nil => 0\n    case Cons(_, tail) => 1 + Length(tail)\n}\n\nmethod Duplicate<T>(xs: List<T>) returns (result: List<T>)\n    ensures Length(result) == 2 * Length(xs)\n{\n    result := Nil;\n    var temp := xs;\n    while temp != Nil\n        decreases temp\n    {\n        var h: T;\n        var t: List<T>;\n        match temp\n        case Nil => \n        case Cons(h, t) => {\n            result := Cons(h, Cons(h, result));\n            temp := t;\n        }\n    }\n}", "completion": "datatype List<T> = Nil | Cons(head: T, tail: List<T>)\n\nfunction Length<T>(xs: List<T>): nat {\n    match xs\n    case Nil => 0\n    case Cons(_, tail) => 1 + Length(tail)\n}\n\nmethod Duplicate<T>(xs: List<T>) returns (result: List<T>)\n    ensures Length(result) == 2 * Length(xs)\n{\n    result := Nil;\n    var temp := xs;\n    while temp != Nil\n        decreases temp\n        invariant Length(result) == 2 * (Length(xs) - Length(temp))\n    {\n        var h: T;\n        var t: List<T>;\n        match temp\n        case Nil => \n        case Cons(h, t) => {\n            result := Cons(h, Cons(h, result));\n            temp := t;\n        }\n    }\n}"}, {"prompt": "method main(i: int, j: int) returns (x: int, y: int)\nrequires i >= 0 && j >= 0\nensures (i != j) || (y == 0)\n{\n    x := i;\n    y := j;\n\n    while(x != 0)\n    {\n        x := x - 1;\n        y := y - 1;\n    }\n}", "completion": "method main(i: int, j: int) returns (x: int, y: int)\nrequires i >= 0 && j >= 0\nensures (i != j) || (y == 0)\n{\n    x := i;\n    y := j;\n\n    while(x != 0)\n    invariant x >= 0;\n    invariant y == j - (i - x);\n    {\n        x := x - 1;\n        y := y - 1;\n    }\n}"}, {"prompt": "method rearrange(arr: array<int>, N: int) returns (front: int)\n    requires N == arr.Length\n    requires forall i :: 0 <= i < arr.Length ==> arr[i] == 0 || arr[i] == 1\n    modifies arr\n    ensures 0 <= front <= arr.Length\n    ensures forall i :: 0 <= i <= front - 1 ==> arr[i] == 0\n    ensures forall j :: front <= j <= N - 1 ==> arr[j] == 1\n    ensures multiset(arr[..]) == old(multiset(arr[..]))\n{   \n    front := 0;\n    var back := N;\n    while(front < back)\n    {\n        if(arr[front] == 1){\n            arr[front], arr[back - 1] := arr[back - 1], arr[front];\n            back := back - 1;\n        }else{\n            front := front + 1;\n        }\n    }\n    return front;\n}", "completion": "method rearrange(arr: array<int>, N: int) returns (front: int)\n    requires N == arr.Length\n    requires forall i :: 0 <= i < arr.Length ==> arr[i] == 0 || arr[i] == 1\n    modifies arr\n    ensures 0 <= front <= arr.Length\n    ensures forall i :: 0 <= i <= front - 1 ==> arr[i] == 0\n    ensures forall j :: front <= j <= N - 1 ==> arr[j] == 1\n    ensures multiset(arr[..]) == old(multiset(arr[..]))\n{   \n    front := 0;\n    var back := N;\n    while(front < back)\n        invariant 0 <= front <= back <= N\n        invariant forall i :: 0 <= i < arr.Length ==> arr[i] == 0 || arr[i] == 1\n        invariant forall i :: 0 <= i <= front - 1 ==> arr[i] == 0\n        invariant forall j :: back <= j < N ==> arr[j] == 1\n        invariant multiset(arr[..]) == old(multiset(arr[..]))\n    {\n        if(arr[front] == 1){\n            arr[front], arr[back - 1] := arr[back - 1], arr[front];\n            back := back - 1;\n        }else{\n            front := front + 1;\n        }\n    }\n    return front;\n}"}, {"prompt": "method main(n: int) returns (a: int, b: int)\n    requires n >= 0\n    ensures a + b == 3 * n\n{\n    var i: int := 0;\n    a := 0;\n    b := 0;\n\n    while(i < n)\n    {\n        if(*)\n        {\n            a := a + 1;\n            b := b + 2;\n        }\n        else\n        {\n            a := a + 2;\n            b := b + 1;\n        }\n\n        i := i + 1;\n    }\n}\n\n", "completion": "method main(n: int) returns (a: int, b: int)\n    requires n >= 0\n    ensures a + b == 3 * n\n{\n    var i: int := 0;\n    a := 0;\n    b := 0;\n\n    while(i < n)\n        invariant 0 <= i <= n\n        invariant a + b == 3 * i\n    {\n        if(*)\n        {\n            a := a + 1;\n            b := b + 2;\n        }\n        else\n        {\n            a := a + 2;\n            b := b + 1;\n        }\n\n        i := i + 1;\n    }\n}\n\n"}, {"prompt": "method main(x :int) returns (j :int, i :int)\nrequires x > 0\nensures j == 2 * x\n{\n    i := 0;\n    j := 0;\n\n    while i < x\n    {\n        j := j + 2;\n        i := i + 1;\n    }\n}", "completion": "method main(x :int) returns (j :int, i :int)\nrequires x > 0\nensures j == 2 * x\n{\n    i := 0;\n    j := 0;\n\n    while i < x\n        invariant 0 <= i <= x\n        invariant j == 2 * i\n    {\n        j := j + 2;\n        i := i + 1;\n    }\n}"}, {"prompt": "method Quotient()\n{\n    var x, y := 0, 191;\n    while 7 <= y\n    {\n        y := y - 7;\n        x := x + 1;\n    }\n    assert x == 191 / 7 && y == 191 % 7;\n}", "completion": "method Quotient()\n{\n    var x, y := 0, 191;\n    while 7 <= y\n    invariant 0 <= y && 7 * x + y == 191\n    {\n        y := y - 7;\n        x := x + 1;\n    }\n    assert x == 191 / 7 && y == 191 % 7;\n}"}, {"prompt": "method add_small_numbers (a: array<int>, n: int, max: int) returns (r: int)\n\trequires n > 0;\n    requires n <= a.Length;\n\trequires (forall i: int :: 0 <= i && i < n ==> a[i] <= max);\n\tensures r <= max * n;\n{\n\tvar i: int;\t\n\n\ti := 0;\n\tr := 0;\n\n\twhile (i < n)\n\t{\n\t\tr := r + a[i];\n\t\ti := i + 1;\n\t}\n}", "completion": "method add_small_numbers (a: array<int>, n: int, max: int) returns (r: int)\n\trequires n > 0;\n    requires n <= a.Length;\n\trequires (forall i: int :: 0 <= i && i < n ==> a[i] <= max);\n\tensures r <= max * n;\n{\n\tvar i: int;\t\n\n\ti := 0;\n\tr := 0;\n\n\twhile (i < n)\n\t\tinvariant i <= n;\n\t\tinvariant r <= max * i;\n\t{\n\t\tr := r + a[i];\n\t\ti := i + 1;\n\t}\n}"}, {"prompt": "method SlopeSearch(a: array2<int>, key: int) returns (m: int, n: int)\n    requires forall i, j, j1 ::\n        0 <= i < a.Length0 && 0 <= j < j1 < a.Length1 ==>\n        a[i,j] <= a[i,j1]\n    requires forall i, i1, j ::\n        0 <= i < i1 < a.Length0 && 0 <= j < a.Length1 ==>\n        a[i,j] <= a[i1,j]\n    requires exists i, j ::\n        0 <= i < a.Length0 && 0 <= j < a.Length1 && a[i,j] == key\n    ensures 0 <= m < a.Length0 && 0 <= n < a.Length1\n    ensures a[m,n] == key\n{\n    m, n := 0, a.Length1 - 1;\n    while a[m,n] != key\n        decreases a.Length0 - m + n\n    {\n        if a[m,n] < key {\n            m := m + 1;\n        } else {\n            n := n - 1;\n        }\n    }\n}", "completion": "method SlopeSearch(a: array2<int>, key: int) returns (m: int, n: int)\n    requires forall i, j, j1 ::\n        0 <= i < a.Length0 && 0 <= j < j1 < a.Length1 ==>\n        a[i,j] <= a[i,j1]\n    requires forall i, i1, j ::\n        0 <= i < i1 < a.Length0 && 0 <= j < a.Length1 ==>\n        a[i,j] <= a[i1,j]\n    requires exists i, j ::\n        0 <= i < a.Length0 && 0 <= j < a.Length1 && a[i,j] == key\n    ensures 0 <= m < a.Length0 && 0 <= n < a.Length1\n    ensures a[m,n] == key\n{\n    m, n := 0, a.Length1 - 1;\n    while a[m,n] != key\n        invariant 0 <= m < a.Length0 && 0 <= n < a.Length1\n        invariant exists i, j :: m <= i < a.Length0 && 0 <= j <= n && a[i,j] == key\n        // invariant exists i, j :: 0 <= i < a.Length0 && 0 <= j < a.Length1 && a[i,j] == key\n        // invariant forall i, j :: 0 <= i < a.Length0 && 0 <= j < a.Length1 ==> (a[i,j] == key || (i > m && j < n))\n        decreases a.Length0 - m + n\n    {\n        if a[m,n] < key {\n            m := m + 1;\n        } else {\n            n := n - 1;\n        }\n    }\n}"}, {"prompt": "method Main1() returns (x: int, y: int)\nensures y > 0\n{\n    x := -50;\n    y := 1;\n\n    while(x < 0)\n        decreases (-x)\n    {\n        x := x + y;\n        y := y + 1;\n    }\n}", "completion": "method Main1() returns (x: int, y: int)\nensures y > 0\n{\n    x := -50;\n    y := 1;\n\n    while(x < 0)\n        decreases (-x)\n        invariant -50 <= x <= y\n        invariant 0 < y <= x + 51\n    {\n        x := x + y;\n        y := y + 1;\n    }\n}"}, {"prompt": "method main(n : int) returns (i: int, x: int, y:int)\nrequires n >= 0\nensures (i % 2 != 0) || (x == 2 * y)\n{\n    i := 0;\n    x := 0;\n    y := 0;\n\n    while (i < n)\n    {\n        i := i + 1;\n        x := x + 1;\n        if (i % 2 == 0)\n        {\n            y := y + 1;\n        }\n        else\n        {}\n    }\n}", "completion": "method main(n : int) returns (i: int, x: int, y:int)\nrequires n >= 0\nensures (i % 2 != 0) || (x == 2 * y)\n{\n    i := 0;\n    x := 0;\n    y := 0;\n\n    while (i < n)\n        invariant 0 <= i <= n\n        invariant x == i\n        invariant y == i / 2\n    {\n        i := i + 1;\n        x := x + 1;\n        if (i % 2 == 0)\n        {\n            y := y + 1;\n        }\n        else\n        {}\n    }\n}"}, {"prompt": "method main(n: int) returns (sum: int, i: int)\nrequires n >= 0\n{\n    sum := 0;\n    i := 0;\n    while(i < n)\n    {\n        sum := sum + i;\n        i := i + 1;\n    }\n}", "completion": "method main(n: int) returns (sum: int, i: int)\nrequires n >= 0\n{\n    sum := 0;\n    i := 0;\n    while(i < n)\n        invariant sum >= 0\n        invariant 0 <= i <= n\n    {\n        sum := sum + i;\n        i := i + 1;\n    }\n}"}, {"prompt": "method square (n: int, x: int) returns (r: int)\n\trequires 0 <= n;\n\trequires x == n;\n\tensures r == x*n;\n{\n\tvar i: int;\n\n\ti := 0;\n\tr := 0;\n\n\twhile (i < n)\n\t{\n\t\tr := r + n;\n\t\ti := i + 1;\n\t}\n}", "completion": "method square (n: int, x: int) returns (r: int)\n\trequires 0 <= n;\n\trequires x == n;\n\tensures r == x*n;\n{\n\tvar i: int;\n\n\ti := 0;\n\tr := 0;\n\n\twhile (i < n)\n\t  invariant i <= n;\n\t  invariant r == i * n;\n\t{\n\t\tr := r + n;\n\t\ti := i + 1;\n\t}\n}"}, {"prompt": "function Dist(x: int, y: int): nat {\n  if x < y then y - x else x - y\n}\n\nmethod CanyonSearch(a: array<int>, b: array<int>) returns (d: nat)\n  requires a.Length != 0 && b.Length != 0\n  requires forall i,j :: 0 <= i < j < a.Length ==> a[i] <= a[j]\n  requires forall i,j :: 0 <= i < j < b.Length ==> b[i] <= b[j]\n  ensures exists i, j :: 0 <= i < a.Length && 0 <= j < b.Length && d == Dist(a[i],b[j])\n  ensures forall i, j :: 0 <= i < a.Length && 0 <= j < b.Length ==> d <= Dist(a[i],b[j])\n  {\n    d := Dist(a[0],b[0]);\n    var m,n := 0,0;\n    while m < a.Length && n < b.Length\n      decreases b.Length - n, a.Length - m   \n    {\n      if Dist(a[m],b[n]) < d {\n        d := Dist(a[m],b[n]);\n      }\n      if a[m] < b[n] {\n        m := m + 1;\n      } else {\n        n := n + 1;\n        m := 0;\n      }\n    }\n  }", "completion": "function Dist(x: int, y: int): nat {\n  if x < y then y - x else x - y\n}\n\nmethod CanyonSearch(a: array<int>, b: array<int>) returns (d: nat)\n  requires a.Length != 0 && b.Length != 0\n  requires forall i,j :: 0 <= i < j < a.Length ==> a[i] <= a[j]\n  requires forall i,j :: 0 <= i < j < b.Length ==> b[i] <= b[j]\n  ensures exists i, j :: 0 <= i < a.Length && 0 <= j < b.Length && d == Dist(a[i],b[j])\n  ensures forall i, j :: 0 <= i < a.Length && 0 <= j < b.Length ==> d <= Dist(a[i],b[j])\n  {\n    d := Dist(a[0],b[0]);\n    var m,n := 0,0;\n    while m < a.Length && n < b.Length\n      invariant exists i, j :: 0 <= i < a.Length && 0 <= j < b.Length && d == Dist(a[i],b[j])\n      invariant forall i, j :: 0 <= i < a.Length && 0 <= j < b.Length ==> d <= Dist(a[i],b[j]) || (i >= m && j >= n)\n      decreases b.Length - n, a.Length - m   \n    {\n      if Dist(a[m],b[n]) < d {\n        d := Dist(a[m],b[n]);\n      }\n      if a[m] < b[n] {\n        m := m + 1;\n      } else {\n        n := n + 1;\n        m := 0;\n      }\n    }\n  }"}, {"prompt": "method BinarySearch(a: array<int>, key: int) returns (n: int)\n    requires forall i, j :: 0 <= i < j < a.Length ==> a[i] <= a[j]\n    ensures 0 <= n <= a.Length\n    ensures forall i :: 0 <= i < n ==> a[i] < key\n    ensures forall i :: n <= i < a.Length ==> key <= a[i]\n{\n    var lo, hi := 0, a.Length;\n\n    while lo < hi\n    {\n        var mid := (lo + hi) / 2;\n\n        if a[mid] < key {\n            lo := mid + 1;\n        } else {\n            hi := mid;\n        }\n    }\n\n    n := lo;\n}\n", "completion": "method BinarySearch(a: array<int>, key: int) returns (n: int)\n    requires forall i, j :: 0 <= i < j < a.Length ==> a[i] <= a[j]\n    ensures 0 <= n <= a.Length\n    ensures forall i :: 0 <= i < n ==> a[i] < key\n    ensures forall i :: n <= i < a.Length ==> key <= a[i]\n{\n    var lo, hi := 0, a.Length;\n\n    while lo < hi\n        invariant 0 <= lo <= hi <= a.Length\n        invariant forall i :: 0 <= i < lo ==> a[i] < key\n        invariant forall i :: hi <= i < a.Length ==> key <= a[i]\n    {\n        var mid := (lo + hi) / 2;\n\n        if a[mid] < key {\n            lo := mid + 1;\n        } else {\n            hi := mid;\n        }\n    }\n\n    n := lo;\n}\n"}, {"prompt": "function sorted(a: array<int>, fromIndex: int, toIndex: int): bool\nreads a\n  requires fromIndex >= 0 && toIndex <= a.Length && fromIndex <= toIndex\n{\n  forall i, j :: fromIndex <= i <= j < toIndex ==> a[i] <= a[j]\n}\n\nmethod merge(a: array<int>, start: int, mid: int, n: int) returns (b: array<int>)\n  requires n <= a.Length;\n  requires 0 <= start;\n  requires start <= mid;\n  requires mid <= n;\n  requires sorted(a, start, mid);\n  requires sorted(a, mid, n);\n  ensures b.Length == a.Length;\n{\n  var i, l, r: int;\n  b := new int[a.Length];\n\n  i, l, r := start, start, mid;\n  \n  while (i < n)\n  {\n    if r >= n || (l < mid && a[l] < a[r]) {\n      b[i] := a[l];\n      l := l + 1;\n    } else {\n      b[i] := a[r];\n      r := r + 1;\n    }\n    i := i + 1;\n  }\n}\n", "completion": "function sorted(a: array<int>, fromIndex: int, toIndex: int): bool\nreads a\n  requires fromIndex >= 0 && toIndex <= a.Length && fromIndex <= toIndex\n{\n  forall i, j :: fromIndex <= i <= j < toIndex ==> a[i] <= a[j]\n}\n\nmethod merge(a: array<int>, start: int, mid: int, n: int) returns (b: array<int>)\n  requires n <= a.Length;\n  requires 0 <= start;\n  requires start <= mid;\n  requires mid <= n;\n  requires sorted(a, start, mid);\n  requires sorted(a, mid, n);\n  ensures b.Length == a.Length;\n{\n  var i, l, r: int;\n  b := new int[a.Length];\n\n  i, l, r := start, start, mid;\n  \n  while (i < n)\n    invariant start <= i <= n;\n    invariant start <= l <= mid;\n    invariant mid <= r <= n;\n    invariant forall j, k :: l <= j && j < k && k < mid ==> a[j] <= a[k];\n    invariant forall j, k :: r <= j && j < k && k < n ==> a[j] <= a[k];\n    invariant l < mid ==> forall j :: start <= j && j < i ==> b[j] <= a[l];\n    invariant r < n ==> forall j :: start <= j && j < i ==> b[j] <= a[r];\n    invariant n - i == (mid - l) + (n - r);\n    invariant sorted(b, start, i);\n  {\n    if r >= n || (l < mid && a[l] < a[r]) {\n      b[i] := a[l];\n      l := l + 1;\n    } else {\n      b[i] := a[r];\n      r := r + 1;\n    }\n    i := i + 1;\n  }\n}\n"}, {"prompt": "function contains(v: int, a: array<int>, n: int): bool\nreads a\n  requires n <= a.Length\n{\n  exists j :: 0 <= j < n && a[j] == v\n}\n\nfunction upper_bound(v: int, a: array<int>, n: int): bool\nreads a\n  requires n <= a.Length\n{\n  forall j :: 0 <= j < n ==> a[j] <= v\n}\n\nmethod max(a: array<int>, n: int) returns (max: int)\n  requires n > 0;\n  requires n <= a.Length;\n  ensures exists j :: 0 <= j < n && a[j] == max;\n  ensures forall j :: 0 <= j < n ==> a[j] <= max;\n{\n  var i: int;\n  max := a[0];\n  i := 1;\n\n  while i < n\n  {\n    if a[i] > max {\n      max := a[i];\n    }\n    i := i + 1;\n  }\n}\n", "completion": "function contains(v: int, a: array<int>, n: int): bool\nreads a\n  requires n <= a.Length\n{\n  exists j :: 0 <= j < n && a[j] == v\n}\n\nfunction upper_bound(v: int, a: array<int>, n: int): bool\nreads a\n  requires n <= a.Length\n{\n  forall j :: 0 <= j < n ==> a[j] <= v\n}\n\nmethod max(a: array<int>, n: int) returns (max: int)\n  requires n > 0;\n  requires n <= a.Length;\n  ensures exists j :: 0 <= j < n && a[j] == max;\n  ensures forall j :: 0 <= j < n ==> a[j] <= max;\n{\n  var i: int;\n  max := a[0];\n  i := 1;\n\n  while i < n\n    invariant i <= n;\n    invariant contains(max, a, i);\n    invariant upper_bound(max, a, i);\n  {\n    if a[i] > max {\n      max := a[i];\n    }\n    i := i + 1;\n  }\n}\n"}]