[{"prompt": "\nmethod SelectionSort(a: array<int>)\n  modifies a\n  ensures forall i,j :: 0 <= i < j < a.Length ==> a[i] <= a[j]\n  ensures multiset(a[..]) == old(multiset(a[..]))\n{\n  var n := 0;\n  while n != a.Length\n  {\n    var mindex, m := n, n;\n    while m != a.Length\n    {\n      if a[m] < a[mindex] {\n        mindex := m;\n      }\n      m := m + 1;\n    }\n    if a[mindex] < a[n] {\n      a[mindex], a[n] := a[n], a[mindex];\n    }\n    n := n + 1;\n  }  \n}", "completion": "// Works by dividing the input list into two parts: sorted and unsorted. At the beginning, \n// the sorted part is empty and the unsorted part contains all the elements.\nmethod SelectionSort(a: array<int>)\n  modifies a\n  // Ensures the final array is sorted in ascending order\n  ensures forall i,j :: 0 <= i < j < a.Length ==> a[i] <= a[j]\n  // Ensures that the final array has the same elements as the initial array\n  ensures multiset(a[..]) == old(multiset(a[..]))\n{\n  var n := 0;\n  while n != a.Length\n    // Ensures that n is always within the bounds of the array\n    invariant 0 <= n <= a.Length\n    // Guarantees that the portion of the array up to index n is sorted\n    invariant forall i,j :: 0 <= i < j < a.Length && j < n ==> a[i] <= a[j]\n    // Guarantees that all elements before n are less than or equal to elements after and at n\n    invariant forall i :: 0 <= i < n ==> forall j :: n <= j < a.Length ==> a[i] <= a[j]\n    // Ensures that the array still contains the same elements as the initial array\n    invariant multiset(a[..]) == old(multiset(a[..]))\n  {\n    var mindex, m := n, n;\n    while m != a.Length\n      // Ensures that mindex is always within the bounds of the array\n      invariant n <= mindex < a.Length\n      invariant n <= m <= a.Length\n      // Ensures that a[mindex] is the smallest element from a[n] to a[m-1]\n      invariant forall i :: n <= i < m ==> a[mindex] <= a[i]\n      // Ensures that the array still contains the same elements as the initial array\n      invariant multiset(a[..]) == old(multiset(a[..]))\n    {\n      if a[m] < a[mindex] {\n        mindex := m;\n      }\n      m := m + 1;\n    }\n    // Swaps the first element of the unsorted array with the current smallest element\n    // in the unsorted part if it is smaller\n    if a[mindex] < a[n] {\n      a[mindex], a[n] := a[n], a[mindex];\n    }\n    n := n + 1;\n  }  \n}"}, {"prompt": "\nmethod rearrange(arr: array<int>, N: int) returns (front: int)\n    requires N == arr.Length\n    requires forall i :: 0 <= i < arr.Length ==> arr[i] == 0 || arr[i] == 1\n    modifies arr\n    ensures 0 <= front <= arr.Length\n    ensures forall i :: 0 <= i <= front - 1 ==> arr[i] == 0\n    ensures forall j :: front <= j <= N - 1 ==> arr[j] == 1\n    ensures multiset(arr[..]) == old(multiset(arr[..]))\n{   \n    front := 0;\n    var back := N;\n    while(front < back)\n    {\n        if(arr[front] == 1){\n            arr[front], arr[back - 1] := arr[back - 1], arr[front];\n            back := back - 1;\n        }else{\n            front := front + 1;\n        }\n    }\n    return front;\n}", "completion": "// Rearrange an array of 0s and 1s such that all 0s are before all 1s\nmethod rearrange(arr: array<int>, N: int) returns (front: int)\n    requires N == arr.Length\n    // Requires that the array only contains 0s and 1s\n    requires forall i :: 0 <= i < arr.Length ==> arr[i] == 0 || arr[i] == 1\n    modifies arr\n    // Ensures that front is the index of the first 1\n    ensures 0 <= front <= arr.Length\n    // Ensures that all 0s are before all 1s\n    ensures forall i :: 0 <= i <= front - 1 ==> arr[i] == 0\n    ensures forall j :: front <= j <= N - 1 ==> arr[j] == 1\n    // Ensures that the elements of the array is unchanged\n    ensures multiset(arr[..]) == old(multiset(arr[..]))\n{   \n    front := 0;\n    var back := N;\n    while(front < back)\n        invariant 0 <= front <= back <= N\n        // Guranatees that the array only contains 0s and 1s\n        invariant forall i :: 0 <= i < arr.Length ==> arr[i] == 0 || arr[i] == 1\n        // Guranatees that all elements are 0 in range [0, front - 1]\n        invariant forall i :: 0 <= i <= front - 1 ==> arr[i] == 0\n        // Guranatees that all elements are 1 in range [back, N - 1]\n        invariant forall j :: back <= j < N ==> arr[j] == 1\n        // Guranatees that the elements of the array is unchanged\n        invariant multiset(arr[..]) == old(multiset(arr[..]))\n    {\n        if(arr[front] == 1){\n            arr[front], arr[back - 1] := arr[back - 1], arr[front];\n            back := back - 1;\n        }else{\n            front := front + 1;\n        }\n    }\n    return front;\n}"}, {"prompt": "method SlopeSearch(a: array2<int>, key: int) returns (m: int, n: int)\n    requires forall i, j, j1 ::\n        0 <= i < a.Length0 && 0 <= j < j1 < a.Length1 ==>\n        a[i,j] <= a[i,j1]\n    requires forall i, i1, j ::\n        0 <= i < i1 < a.Length0 && 0 <= j < a.Length1 ==>\n        a[i,j] <= a[i1,j]\n    requires exists i, j ::\n        0 <= i < a.Length0 && 0 <= j < a.Length1 && a[i,j] == key\n    ensures 0 <= m < a.Length0 && 0 <= n < a.Length1\n    ensures a[m,n] == key\n{\n    m, n := 0, a.Length1 - 1;\n    while a[m,n] != key\n        decreases a.Length0 - m + n\n    {\n        if a[m,n] < key {\n            m := m + 1;\n        } else {\n            n := n - 1;\n        }\n    }\n}", "completion": "// Looks for a key in a sloping landscape. More precisely, the landscape is a \n// rectangular area where any step North or East takes you to higher (or unchanged) elevations.\n// A typical way to indicate elevations in a 2-dimensional map is to draw contour lines that \n// connect the points with equal elevation.\nmethod SlopeSearch(a: array2<int>, key: int) returns (m: int, n: int)\n    // Requires that the array is sorted in ascending order\n    requires forall i, j, j1 ::\n        0 <= i < a.Length0 && 0 <= j < j1 < a.Length1 ==>\n        a[i,j] <= a[i,j1]\n    requires forall i, i1, j ::\n        0 <= i < i1 < a.Length0 && 0 <= j < a.Length1 ==>\n        a[i,j] <= a[i1,j]\n    // Requires key can be calculated from the elements array\n    requires exists i, j ::\n        0 <= i < a.Length0 && 0 <= j < a.Length1 && a[i,j] == key\n    // Ensure m, n are in range and represent the same value as key\n    ensures 0 <= m < a.Length0 && 0 <= n < a.Length1\n    ensures a[m,n] == key\n{\n    m, n := 0, a.Length1 - 1;\n    while a[m,n] != key\n        invariant 0 <= m < a.Length0 && 0 <= n < a.Length1\n        // For the 2-D array a, ensures there are two indices i, j in range (m, a.Length0) \n        // and (0, n) respectively such that a[i,j] == key.\n        invariant exists i, j :: m <= i < a.Length0 && 0 <= j <= n && a[i,j] == key\n        decreases a.Length0 - m + n\n    {\n        if a[m,n] < key {\n            m := m + 1;\n        } else {\n            n := n - 1;\n        }\n    }\n}"}, {"prompt": "function Dist(x: int, y: int): nat {\n  if x < y then y - x else x - y\n}\n\nmethod CanyonSearch(a: array<int>, b: array<int>) returns (d: nat)\n  requires a.Length != 0 && b.Length != 0\n  requires forall i,j :: 0 <= i < j < a.Length ==> a[i] <= a[j]\n  requires forall i,j :: 0 <= i < j < b.Length ==> b[i] <= b[j]\n  ensures exists i, j :: 0 <= i < a.Length && 0 <= j < b.Length && d == Dist(a[i],b[j])\n  ensures forall i, j :: 0 <= i < a.Length && 0 <= j < b.Length ==> d <= Dist(a[i],b[j])\n  {\n    d := Dist(a[0],b[0]);\n    var m,n := 0,0;\n    while m < a.Length && n < b.Length\n      decreases b.Length - n, a.Length - m   \n    {\n      if Dist(a[m],b[n]) < d {\n        d := Dist(a[m],b[n]);\n      }\n      if a[m] < b[n] {\n        m := m + 1;\n      } else {\n        n := n + 1;\n        m := 0;\n      }\n    }\n  }", "completion": "function Dist(x: int, y: int): nat {\n  if x < y then y - x else x - y\n}\n\n// Find the pair of numbers, one from each of the two sorted arrays, \n// that have the smallest absolute difference.\nmethod CanyonSearch(a: array<int>, b: array<int>) returns (d: nat)\n  // Require two arrays of integers are not empty\n  requires a.Length != 0 && b.Length != 0\n  // Require two arrays of integers are sorted\n  requires forall i,j :: 0 <= i < j < a.Length ==> a[i] <= a[j]\n  requires forall i,j :: 0 <= i < j < b.Length ==> b[i] <= b[j]\n  // Ensure the result is the smallest absolute difference \n  // which calculated from elements from these two arrays\n  ensures exists i, j :: 0 <= i < a.Length && 0 <= j < b.Length && d == Dist(a[i],b[j])\n  ensures forall i, j :: 0 <= i < a.Length && 0 <= j < b.Length ==> d <= Dist(a[i],b[j])\n  {\n    // Initialize the smallest absolute difference as the first element of two arrays\n    d := Dist(a[0],b[0]);\n    var m,n := 0,0;\n    while m < a.Length && n < b.Length\n      // Ensure d can be calculated from elements from these two arrays\n      invariant exists i, j :: 0 <= i < a.Length && 0 <= j < b.Length && d == Dist(a[i],b[j])\n      // Ensure d is the smallest absolute difference\n      invariant forall i, j :: 0 <= i < a.Length && 0 <= j < b.Length ==> d <= Dist(a[i],b[j]) || (i >= m && j >= n)\n      decreases b.Length - n, a.Length - m   \n    {\n      if Dist(a[m],b[n]) < d {\n        d := Dist(a[m],b[n]);\n      }\n      if a[m] < b[n] {\n        m := m + 1;\n      } else {\n        n := n + 1;\n        m := 0;\n      }\n    }\n  }"}, {"prompt": "function sorted(a: array<int>, fromIndex: int, toIndex: int): bool\nreads a\n  requires fromIndex >= 0 && toIndex <= a.Length && fromIndex <= toIndex\n{\n  forall i, j :: fromIndex <= i <= j < toIndex ==> a[i] <= a[j]\n}\n\nmethod merge(a: array<int>, start: int, mid: int, n: int) returns (b: array<int>)\n  requires n <= a.Length;\n  requires 0 <= start;\n  requires start <= mid;\n  requires mid <= n;\n  requires sorted(a, start, mid);\n  requires sorted(a, mid, n);\n  ensures b.Length == a.Length;\n{\n  var i, l, r: int;\n  b := new int[a.Length];\n  i, l, r := start, start, mid;\n  \n  while (i < n)\n  {\n    if r >= n || (l < mid && a[l] < a[r]) {\n      b[i] := a[l];\n      l := l + 1;\n    } else {\n      b[i] := a[r];\n      r := r + 1;\n    }\n    i := i + 1;\n  }\n}", "completion": "function sorted(a: array<int>, fromIndex: int, toIndex: int): bool\nreads a\n  requires fromIndex >= 0 && toIndex <= a.Length && fromIndex <= toIndex\n{\n  forall i, j :: fromIndex <= i <= j < toIndex ==> a[i] <= a[j]\n}\n\n// Divid an unsorted list into sublists, sorting them, and then merging them back \n// together to form a sorted list.\nmethod merge(a: array<int>, start: int, mid: int, n: int) returns (b: array<int>)\n  requires n <= a.Length;\n  requires 0 <= start;\n  requires start <= mid;\n  requires mid <= n;\n  // The first subarray (from 'start' to 'mid') must be sorted.\n  requires sorted(a, start, mid);\n  // The second subarray (from 'mid' to 'n') must be sorted.\n  requires sorted(a, mid, n);\n  // The length of the output array 'b' must be the same as the length of the input array 'a'.\n  ensures b.Length == a.Length;\n{\n  var i, l, r: int;\n  b := new int[a.Length];\n  i, l, r := start, start, mid;\n  \n  while (i < n)\n    invariant start <= i <= n;\n    invariant start <= l <= mid;\n    invariant mid <= r <= n;\n    // All elements in the left subarray are in ascending order.\n    invariant forall j, k :: l <= j && j < k < mid ==> a[j] <= a[k];\n    // All elements in the right subarray are in ascending order.\n    invariant forall j, k :: r <= j && j < k < n ==> a[j] <= a[k];\n    // Each element in 'b' is no larger than the smallest remaining element in the left subarray of 'a'.\n    invariant l < mid ==> forall j :: start <= j < i ==> b[j] <= a[l];\n    // Each element in 'b' is no larger than the smallest remaining element in the right subarray of 'a'.\n    invariant r < n ==> forall j :: start <= j < i ==> b[j] <= a[r];\n    // The total number of remaining elements is constant.\n    invariant n - i == (mid - l) + (n - r);\n    // The part of 'b' that has been filled in is sorted.\n    invariant sorted(b, start, i);\n  {\n    if r >= n || (l < mid && a[l] < a[r]) {\n      b[i] := a[l];\n      l := l + 1;\n    } else {\n      b[i] := a[r];\n      r := r + 1;\n    }\n    i := i + 1;\n  }\n}"}]